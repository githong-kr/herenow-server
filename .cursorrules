# HereNow Backend Server (.cursorrules)

당신은 HereNow 백엔드 서버(`herenow-server`)의 유지보수 및 개발을 담당하는 고급 AI 어시스턴트입니다.
이 프로젝트는 Spring Boot(Kotlin) 기반으로 작성되었으며, 테스트 환경에서는 로컬 H2 DB를, 운영 환경에서는 Supabase PostgreSQL을 사용합니다.
서버 코드를 작성하거나 수정할 때, **반드시 아래의 아키텍처 규칙과 프로젝트 컨벤션을 준수**하십시오.

## 1. 기술 스택 및 환경
- **언어**: Kotlin 2.x
- **프레임워크**: Spring Boot 3.5.x
- **빌드 도구**: Gradle (Kotlin DSL)
- **데이터베이스**: PostgreSQL 17 (Supabase 운영망) 및 H2 Database (로컬/테스트망)
- **사용자 인증**: Supabase Auth 기반 JWT 토큰 (Spring Security `OAuth2 Resource Server` 및 `JWKS` 사용)
- **API 문서화**: Springdoc OpenAPI v2 (Swagger)

## 2. API 설계 및 컴포넌트(Controller/Service) 규칙
- 모든 컨트롤러는 `BaseController`를 상속받아야 합니다.
- 모든 비즈니스 도메인 서비스는 `BaseService`를 상속받아야 합니다. (AOP 및 로깅, 컨텍스트 연동 목적)
- **🚨매우 중요🚨**: 모든 엔드포인트 메서드에는 반드시 `@Operation(summary = "...", description = "...")` 애노테이션을 작성해야 합니다.
  - 앱 기동 시 커스텀 이벤트 리스너인 `ApiRegister`가 이 애노테이션을 스캔하여, `api_mst` (API 원장) 데이터베이스 테이블에 API 목록과 설명 등을 자동으로 적재하기 때문입니다. 누락 시 로깅 및 차단 로직에 결함이 발생할 수 있습니다.
- API의 반환 타입은 `ControllerAdvice` 등 글로벌 영역에서 성공/실패 래핑이 적용되므로, 가급적 DTO 객체를 직접 반환하거나 비즈니스 예외 코드를 Throw하는 방식을 취합니다. 

## 3. 데이터베이스 및 JPA 규칙
- **Base Entity**: 모든 DB 테이블 엔티티 클래스는 `BaseEntity`를 상속해야 합니다. `BaseEntity`는 JPA `@EntityListeners(EntityListener::class)`를 통해 다음 감사(Audit) 필드를 자동 관리합니다:
  - 최초등록일시(`frstRegTmst`), 최초등록자(`frstRegGuid`), 최종수정일시(`lastChngTmst`), 최종수정자(`lastChngGuid`)
- **Primary Keys 설계**: 특별한 목적이 없다면 기본키(PK)는 DB 고유 식별자인 `Long` (자동 증가)이나 간단한 `String` 난수로 채택하고, UUID 데이터베이스 네이티브 타입 제약(PostgreSQL 의존성)을 남발하지 마십시오.
- **대용량 문자열 (Text/Lob) 🚨**:
  - `String` 필드에 무분별하게 `@Lob` 애노테이션을 사용하지 마십시오. PostgreSQL 최신 버전에선 `@Lob` 객체를 큰 바이너리 참조 ID인 `oid` 타입으로 치환해버려, 직렬화 시 오류가 발생할 수 있습니다.
  - 많은 양의 문자열, 요청 바디(Body), JSON, 긴 에러 스택 공간이 필요하다면 항상 `@Column(columnDefinition = "TEXT")` 로 명시적으로 지정하십시오.
- **명명 규칙 (Naming Convention)**:
  - `@Table`의 `name`이나 `@Column`의 `name`은 반드시 관례적인 `소문자_스네이크_케이스(snake_case)`로 작성합니다.
  - 코틀린 엔티티의 Property(필드) 이름은 `카멜케이스(camelCase)` 형태를 유지합니다.

## 4. 보안(Security) 및 JWT 토큰 파싱
- `jjwt` 라이브러리 같은 **수동 JWT 해석 필터를 절대 추가하지 마십시오.** 이 프로젝트는 Supabase의 강화된 비대칭키(ECC P-256 등) 토큰 검증 규격을 따르기 위해, Spring Security 기본 내장인 `oauth2ResourceServer(JWT)` 기술을 사용합니다.
- 토큰 공개키 URL(`jwk-set-uri`)은 `.env`의 `TEST_SUPABASE_PROJECT_REF` 또는 `PROD_SUPABASE_PROJECT_REF` 설정값에 따라 자동으로 주입됩니다.
- API 처리 로직 내에서 현재 접속 유저 정보(예: UUID)가 필요할 경우, `SecurityContextHolder.getContext().authentication.name` 경로를 통해 규격별로 안전하게 획득해야 합니다.

## 5. 로깅(Logging) 및 트랜잭션 추적
- 이 프로젝트의 핵심 로깅은 AOP 클래스인 `ControllerAdvice.kt`를 통해 모든 API 진입/진출을 인터셉트(Intersect)하여 단일창구 처리합니다.
- `ControllerAdvice`는 API 호출이 시작될 때 스레드 로컬인 `CustomContext`에 값을 넣고 MDC(Mappned Diagnostic Context)를 활용하여 `guid`, `apiKey`, `apiNm`, `remoteIp`, `elapsed`(수행시간) 메트릭을 고정적으로 세팅합니다.
- **모든 API 요청은 자동으로 `api_call_log` 시스템 테이블에 적재**됩니다. 이때 `apiKey`와 Swagger에 적혀있던 `serviceNm` 요약 텍스트가 DB API 원장과 매칭되어 함께 수집됩니다.

## 6. 환경 변수 및 설정 파일 관리 (.env)
- 주요 접속 정보나 암호들(예: 데이터베이스 패스워드, 외부 연동 Secret)은 절대 커밋 코드 상에 하드코딩하지 않습니다.
- 스프링은 `spring-dotenv` 라이브러리를 통해 프로젝트 최상단의 `.env` 파일을 자동으로 읽어 들입니다. 
- 중요한 환경 설정값 변경은 `application.yml`에 기본 값을 설정하되, `.env`를 활용해 우선 교체되도록 구성하십시오.

## 7. 패키지 및 도메인 구조
코드를 수정하거나 새 폴더를 생성할 때는 아래 구조에 맞추십시오:
- `api/`: 도메인 단위별 비즈니스 디렉토리 (e.g. `api/users/`, `api/groups/`). 내부에 `controller`, `service`, `model(DTO)`가 들어감.
- `lib/model/entity/`: 데이터베이스 테이블 객체 (JPA Entity).
- `lib/model/repository/`: Data JPA 인터페이스 저장소.
- `lib/utils/`: 전역적으로 쓰는 도구/헬퍼 클래스들.
- `fwk/`: 어플리케이션 전반에 깔리는 프레임워크 설정 덩어리들 (AOP 인터셉터, Security Config 설정, 전역 커스텀 예외 등).

**마지막 지침**:
항상 코드를 수정할 때는 이 한국어 디렉티브를 최우선으로 참고하여 프로젝트 전체 구조(커스텀 AOP 로깅 / CustomContext)가 망가지거나 위배되지 않도록 조심하세요.

## 8. Git 및 배포 정책 (엄격한 금지 사항)
- **🚨절대 금지🚨**: 사용자의 명시적인 사전 동의나 "커밋해 줘", "배포해 줘"라는 텍스트 명령어 없이는 **절대로 본인의 판단하에 마음대로 `git commit`, `git push`, `npm run deploy:*` 등의 명령어를 실행하지 마십시오.** 
- 코드 수정을 마친 후에는 "이대로 커밋을 진행할까요?"라고 사용자에게 묻지도 마십시오.
- 단지 코드 수정 내역(diff)만 명확하게 보고하고, 사용자가 직접 리뷰하고 안전하게 커밋을 제어할 수 있도록 그대로 진행을 멈추십시오.

## 9. Kotlin String Template 작성 규칙
- **🚨절대 금지🚨**: Kotlin 코드 내에서 문자열 템플릿(String Template)을 사용할 때 변수 앞에 역슬래시(`\$`)를 붙이지 마십시오.
- 예: `"\${userName}님이..."` (X) -> `"${userName}님이..."` (O)
- 역슬래시를 붙이면 이스케이프 처리되어 변수값이 바인딩되지 않고 리터럴 텍스트로 그대로 노출되는 치명적인 버그가 발생하므로 절대 금지합니다.
