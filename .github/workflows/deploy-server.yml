name: Deploy Spring Boot Server

on:
  push:
    branches:
      - d/prod
      - d/test

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          ENV_FILE_CONTENT: ${{ secrets.ENV_FILE_CONTENT }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          envs: ENV_FILE_CONTENT
          script: |
            set -e
            
            # [HOTFIX 1] macOS SSH 접속 시 docker 경로 및 소켓 인식 우회
            export PATH=$PATH:/usr/local/bin:/opt/homebrew/bin:/Users/${{ secrets.SERVER_USER }}/.docker/bin
            export DOCKER_HOST="unix:///Users/${{ secrets.SERVER_USER }}/.docker/run/docker.sock"
            
            # [HOTFIX 2] SSH 비대화형 환경에서 Desktop Keychain 권한(보안) 에러를 우회하는 가짜 Credential Helper 주입
            mkdir -p /tmp/fake-bin
            cat << 'EOF' > /tmp/fake-bin/docker-credential-osxkeychain
            #!/bin/sh
            echo "credentials not found in native keychain"
            exit 1
            EOF
            cp /tmp/fake-bin/docker-credential-osxkeychain /tmp/fake-bin/docker-credential-desktop
            chmod +x /tmp/fake-bin/docker-credential-*
            export PATH=/tmp/fake-bin:$PATH
            
            # 서버 내부의 프로젝트 Git 경로로 이동
            cd /Users/${{ secrets.SERVER_USER }}/Documents/release/herenow-server
            
            git fetch --all
            
            # Github Secret에서 넘어온 환경 변수 내용을 .env 파일로 동적으로 주입
            echo "$ENV_FILE_CONTENT" > .env
            
            # 운영 서버 배포 (d/prod)
            if [ "${{ github.ref }}" = "refs/heads/d/prod" ]; then
              echo "Deploying Production Environment..."
              git fetch origin d/prod
              git checkout -B d/prod origin/d/prod
              git reset --hard origin/d/prod
              # 1. 빌드 전용 엔진으로 (캐시 없이, 백그라운드 없이) 순수 빌드만 진행 (Keychain 회피)
              docker-compose build --no-cache herenow-prod-api
              # 2. 빌드된 이미지를 띄움
              docker-compose up -d herenow-prod-api
              
              # Health Check (8002 포트 응답 대기, 최대 60초)
              echo "Waiting for prod server to start..."
              for i in {1..12}; do
                # /actuator/health 가 없다면 swagger 나 단순히 루트를 찔러봄
                if curl -s http://localhost:8002/actuator/health > /dev/null || curl -s http://localhost:8002/swagger-ui/index.html > /dev/null; then
                  echo "✅ Production Server (8002) is UP and RUNNING!"
                  break
                fi
                echo "Waiting... ($i/12)"
                sleep 5
                if [ $i -eq 12 ]; then
                  echo "❌ Server failed to respond in time."
                  exit 1
                fi
              done
              
            # 테스트 서버 배포 (d/test)
            elif [ "${{ github.ref }}" = "refs/heads/d/test" ]; then
              echo "Deploying Test/Dev Environment..."
              git fetch origin d/test
              git checkout -B d/test origin/d/test
              git reset --hard origin/d/test
              # 1. 빌드 전용 엔진으로 (캐시 없이, 백그라운드 없이) 순수 빌드만 진행 (Keychain 회피)
              docker-compose build --no-cache herenow-dev-api
              # 2. 빌드된 이미지를 띄움
              docker-compose up -d herenow-dev-api
              
              # Health Check (8001 포트 응답 대기, 최대 60초)
              echo "Waiting for test server to start..."
              for i in {1..12}; do
                if curl -s http://localhost:8001/actuator/health > /dev/null || curl -s http://localhost:8001/swagger-ui/index.html > /dev/null; then
                  echo "✅ Test Server (8001) is UP and RUNNING!"
                  break
                fi
                echo "Waiting... ($i/12)"
                sleep 5
                if [ $i -eq 12 ]; then
                  echo "❌ Server failed to respond in time."
                  exit 1
                fi
              done
            fi
            
            # [HOTFIX 2 정리] 빌드 완료 후 임시 스크립트 삭제
            rm -rf /tmp/fake-bin
            
            # 빌드 이후 사용되지 않는 댕글링 이미지 자동 정리
            docker system prune -af
            docker builder prune -af
