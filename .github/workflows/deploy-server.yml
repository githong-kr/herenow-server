name: Deploy Spring Boot Server

on:
  push:
    branches:
      - d/prod
      - d/test

jobs:
  deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Deploy to Server via SSH
        uses: appleboy/ssh-action@v1.0.3
        env:
          ENV_FILE_CONTENT: ${{ secrets.ENV_FILE_CONTENT }}
        with:
          host: ${{ secrets.SERVER_HOST }}
          username: ${{ secrets.SERVER_USER }}
          key: ${{ secrets.SERVER_KEY }}
          envs: ENV_FILE_CONTENT
          script: |
            # [HOTFIX 1] macOS SSH 접속 시 docker 경로 및 소켓 인식 우회
            export PATH=$PATH:/usr/local/bin:/opt/homebrew/bin:/Users/${{ secrets.SERVER_USER }}/.docker/bin
            export DOCKER_HOST="unix:///Users/${{ secrets.SERVER_USER }}/.docker/run/docker.sock"
            
            # [HOTFIX 2] SSH 환경 빌드 시 데스크탑 BuildKit 캐시 엔진이 keychain 권한을 요구하는 문제 원천 차단
            export DOCKER_BUILDKIT=0
            export COMPOSE_DOCKER_CLI_BUILD=0
            
            # [HOTFIX 2] SSH 환경 빌드 시 데스크탑 keychain 로직 강제 진입 방지를 위해 원본 config 파일 백업 및 무력화
            DOCKER_CONF="/Users/${{ secrets.SERVER_USER }}/.docker/config.json"
            if [ -f "$DOCKER_CONF" ]; then mv "$DOCKER_CONF" "${DOCKER_CONF}.bak"; fi
            # Docker Desktop의 기본값(desktop credential helper) 발동을 강제 차단합니다.
            echo '{"credsStore":""}' > "$DOCKER_CONF"
            
            # 서버 내부의 프로젝트 Git 경로로 이동
            cd /Users/${{ secrets.SERVER_USER }}/Documents/release/herenow-server
            
            git fetch --all
            
            # Github Secret에서 넘어온 환경 변수 내용을 .env 파일로 동적으로 주입
            echo "$ENV_FILE_CONTENT" > .env
            
            # 운영 서버 배포 (d/prod)
            if [ "${{ github.ref }}" = "refs/heads/d/prod" ]; then
              echo "Deploying Production Environment..."
              git checkout d/prod
              git pull origin d/prod
              # 1. 빌드 전용 엔진으로 (캐시 없이, 백그라운드 없이) 순수 빌드만 진행 (Keychain 회피)
              docker-compose build --no-cache herenow-prod-api
              # 2. 빌드된 이미지를 띄움
              docker-compose up -d herenow-prod-api
              
              # Health Check (8002 포트 응답 대기, 최대 60초)
              echo "Waiting for prod server to start..."
              for i in {1..12}; do
                # /actuator/health 가 없다면 swagger 나 단순히 루트를 찔러봄
                if curl -s http://localhost:8002/actuator/health > /dev/null || curl -s http://localhost:8002/swagger-ui/index.html > /dev/null; then
                  echo "✅ Production Server (8002) is UP and RUNNING!"
                  break
                fi
                echo "Waiting... ($i/12)"
                sleep 5
                if [ $i -eq 12 ]; then
                  echo "❌ Server failed to respond in time."
                  if [ -f "${DOCKER_CONF}.bak" ]; then mv "${DOCKER_CONF}.bak" "$DOCKER_CONF"; fi
                  exit 1
                fi
              done
              
            # 테스트 서버 배포 (d/test)
            elif [ "${{ github.ref }}" = "refs/heads/d/test" ]; then
              echo "Deploying Test/Dev Environment..."
              git checkout d/test
              git pull origin d/test
              # 1. 빌드 전용 엔진으로 (캐시 없이, 백그라운드 없이) 순수 빌드만 진행 (Keychain 회피)
              docker-compose build --no-cache herenow-dev-api
              # 2. 빌드된 이미지를 띄움
              docker-compose up -d herenow-dev-api
              
              # Health Check (8001 포트 응답 대기, 최대 60초)
              echo "Waiting for test server to start..."
              for i in {1..12}; do
                if curl -s http://localhost:8001/actuator/health > /dev/null || curl -s http://localhost:8001/swagger-ui/index.html > /dev/null; then
                  echo "✅ Test Server (8001) is UP and RUNNING!"
                  break
                fi
                echo "Waiting... ($i/12)"
                sleep 5
                if [ $i -eq 12 ]; then
                  echo "❌ Server failed to respond in time."
                  if [ -f "${DOCKER_CONF}.bak" ]; then mv "${DOCKER_CONF}.bak" "$DOCKER_CONF"; fi
                  exit 1
                fi
              done
            fi
            
            # [HOTFIX 2 복구] 정상 빌드 종료 후 무력화 파일 삭제 및 백업한 config.json 원복
            rm -f "$DOCKER_CONF"
            if [ -f "${DOCKER_CONF}.bak" ]; then mv "${DOCKER_CONF}.bak" "$DOCKER_CONF"; fi
            
            # 빌드 이후 사용되지 않는 댕글링 이미지 자동 정리
            docker image prune -f
